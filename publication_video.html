<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reels</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        :root {
            --primary: #ff2442;
            --text: #fff;
            --overlay-bg: rgba(0, 0, 0, 0.6);
            --comment-bg: #1e1e1e;
        }
        body, html { margin: 0; padding: 0; background: #000; color: var(--text); font-family: 'Poppins', sans-serif; height: 100%; overflow: hidden; }

        /* Container for snapping */
        .reels-container {
            height: 100%;
            overflow-y: scroll;
            scroll-snap-type: y mandatory;
            scrollbar-width: none; /* Firefox */
        }
        .reels-container::-webkit-scrollbar { display: none; }

        /* Individual Reel */
        .reel-page {
            position: relative;
            width: 100%;
            height: 100vh;
            scroll-snap-align: start;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #000;
            overflow: hidden; /* Important for masking */
        }

        /* Video Layer - Scaled to hide YouTube controls/logo */
        .video-wrapper {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: 1;
            pointer-events: none; /* Let clicks pass to overlay */
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        iframe {
            width: 100%; 
            height: 100%; 
            border: none;
            /* Masking Magic: Scale up to push controls off canvas */
            transform: scale(1.35); 
            transform-origin: center center;
            pointer-events: none; /* Ensure clicks go to the click-layer */
        }

        /* Click Layer for Pause/Like */
        .click-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 2;
        }

        /* Double Tap Heart Animation */
        .big-heart {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%) scale(0);
            font-size: 80px; color: rgba(255, 36, 66, 0.9);
            z-index: 5; pointer-events: none;
            transition: transform 0.2s ease-out, opacity 0.5s ease;
            opacity: 0;
            text-shadow: 0 4px 10px rgba(0,0,0,0.5);
        }
        .big-heart.animate {
            animation: heartPopup 0.8s ease-out forwards;
        }
        @keyframes heartPopup {
            0% { transform: translate(-50%, -50%) scale(0); opacity: 0; }
            30% { transform: translate(-50%, -50%) scale(1.5); opacity: 1; }
            50% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 0; }
        }

        /* Top Bar (Back & Options) */
        .top-nav { position: absolute; top: 20px; left: 20px; z-index: 20; font-size: 24px; cursor: pointer; text-shadow: 0 2px 4px #000; filter: drop-shadow(0 0 5px rgba(0,0,0,0.5)); }
        
        .top-options {
            position: absolute; top: 20px; right: 20px; z-index: 20;
            font-size: 24px; cursor: pointer; color: white;
            text-shadow: 0 2px 4px #000;
            filter: drop-shadow(0 0 5px rgba(0,0,0,0.5));
        }

        /* Options Menu (Dropdown/Modal style) */
        .options-menu {
            position: absolute; top: 60px; right: 20px;
            background: #2a2a2a; border-radius: 8px;
            padding: 5px 0; box-shadow: 0 4px 12px rgba(0,0,0,0.5);
            display: none; flex-direction: column; width: 140px; z-index: 1000;
        }
        .options-menu.show { display: flex; }
        .menu-item {
            padding: 12px 15px; font-size: 14px; color: #eee;
            cursor: pointer; display: flex; align-items: center; gap: 10px;
        }
        .menu-item:hover { background: #3a3a3a; }
        .menu-item.danger { color: #ff4d4f; }

        /* Right Sidebar Actions */
        .actions-bar {
            position: absolute; right: 10px; bottom: 100px;
            z-index: 10; display: flex; flex-direction: column;
            gap: 20px; align-items: center;
        }
        .action-btn {
            display: flex; flex-direction: column; align-items: center; gap: 5px;
            cursor: pointer; text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }
        .action-btn i { font-size: 30px; transition: transform 0.2s; filter: drop-shadow(0 2px 4px rgba(0,0,0,0.5)); }
        .action-btn span { font-size: 12px; font-weight: 600; filter: drop-shadow(0 1px 2px rgba(0,0,0,0.8)); }
        .action-btn:active i { transform: scale(0.8); }
        .liked { color: var(--primary); }

        /* Avatar & Follow */
        .avatar-container { position: relative; margin-bottom: 10px; cursor: pointer; }
        .avatar-img { width: 48px; height: 48px; border-radius: 50%; border: 2px solid #fff; object-fit: cover; box-shadow: 0 2px 5px rgba(0,0,0,0.5); }
        .follow-plus {
            position: absolute; bottom: -8px; left: 50%; transform: translateX(-50%);
            background: var(--primary); color: #fff; width: 20px; height: 20px;
            border-radius: 50%; display: flex; align-items: center; justify-content: center;
            font-size: 12px; cursor: pointer; border: 1px solid #fff;
            transition: transform 0.2s;
        }

        /* Bottom Info */
        .reel-info {
            position: absolute; bottom: 20px; left: 15px; width: 70%;
            z-index: 10; text-shadow: 0 1px 3px rgba(0,0,0,0.8);
            pointer-events: none; /* Let clicks pass through text areas */
        }
        .user-name { font-weight: 700; font-size: 17px; margin-bottom: 8px; display: block; pointer-events: auto; cursor: pointer; }
        .reel-desc { font-size: 14px; line-height: 1.4; max-height: 80px; overflow: hidden; margin-bottom: 8px; opacity: 0.9; }
        .music-note { display: flex; align-items: center; gap: 8px; font-size: 12px; opacity: 0.8; }
        .scrolling-text { white-space: nowrap; overflow: hidden; width: 150px; }

        /* Comments Sheet */
        .comments-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.5); z-index: 100; display: none;
        }
        .comments-sheet {
            position: absolute; bottom: 0; left: 0; width: 100%; height: 70vh;
            background: var(--comment-bg); border-radius: 20px 20px 0 0;
            display: flex; flex-direction: column;
            transform: translateY(100%); transition: transform 0.3s ease-out;
        }
        .sheet-header {
            padding: 15px; text-align: center; border-bottom: 1px solid #333;
            position: relative; font-weight: 600; font-size: 14px;
        }
        .close-sheet { position: absolute; right: 15px; top: 15px; cursor: pointer; }
        .comments-list { flex: 1; overflow-y: auto; padding: 15px; }
        .comment-item { display: flex; gap: 10px; margin-bottom: 20px; }
        .comment-avatar { width: 32px; height: 32px; border-radius: 50%; background: #555; object-fit: cover;}
        .comment-body { flex: 1; font-size: 13px; }
        .comment-user { color: #aaa; font-size: 12px; margin-bottom: 2px; }
        .comment-text { color: #eee; margin-bottom: 5px; }
        .comment-meta { color: #888; font-size: 11px; display: flex; gap: 15px; align-items: center; }
        .reply-link { cursor: pointer; font-weight: 600; color: #888; }
        .comment-input-area {
            padding: 10px 15px; border-top: 1px solid #333; display: flex; align-items: center; gap: 10px;
            background: #252525; padding-bottom: 25px;
        }
        .comment-input-area input {
            flex: 1; background: #121212; border: none; padding: 10px; border-radius: 20px; color: #fff; outline: none;
        }
        .send-btn { color: var(--primary); font-weight: 600; cursor: pointer; }

    </style>
</head>
<body>

    <div class="top-nav" onclick="window.location.href='home.html'">
        <i class="fas fa-arrow-left"></i>
    </div>

    <div class="reels-container" id="reelsContainer"></div>

    <div class="comments-overlay" id="commentsOverlay">
        <div class="comments-sheet" id="commentsSheet">
            <div class="sheet-header">
                <span id="commentCountHeader">0 Comments</span>
                <i class="fas fa-times close-sheet" onclick="closeComments()"></i>
            </div>
            <div class="comments-list" id="commentsList"></div>
            <div class="comment-input-area">
                <img src="https://via.placeholder.com/32" class="comment-avatar" id="myAvatar">
                <input type="text" id="commentInput" placeholder="Add a comment...">
                <div class="send-btn" onclick="postComment()">Post</div>
            </div>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
        import { getFirestore, doc, getDoc, updateDoc, arrayUnion, arrayRemove, collection, addDoc, query, orderBy, limit, startAfter, onSnapshot, serverTimestamp, deleteDoc, writeBatch, increment } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";
        import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";
        import { getDocs, where } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

        const firebaseConfig = {
            apiKey: "AIzaSyAuEfa4lBdoarHqUBmpWnVdYEhLYMUW0Wk",
            authDomain: "rednote-99494.firebaseapp.com",
            projectId: "rednote-99494",
            storageBucket: "rednote-99494.firebasestorage.app",
            messagingSenderId: "381708373042",
            appId: "1:381708373042:web:3b2b66b9aefba8b98bc02b"
        };

        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);
        
        let currentUser = null;
        let currentReelId = null;
        // Pagination & Loop Variables
        let lastVisibleDoc = null; 
        let isFetching = false;
        
        const reelsContainer = document.getElementById('reelsContainer');

        onAuthStateChanged(auth, async (user) => {
            if (user) {
                currentUser = user;
                document.getElementById('myAvatar').src = user.photoURL || 'https://via.placeholder.com/32';
                initPage();
            } else {
                window.location.href = 'index.html';
            }
        });

        async function initPage() {
            const urlParams = new URLSearchParams(window.location.search);
            const initialReelId = urlParams.get('id');

            if (initialReelId) {
                await loadReel(initialReelId, true);
            }
            loadMoreReels(initialReelId);
        }

        async function loadReel(reelId, prepend = false) {
            const reelRef = doc(db, "reels", reelId);
            const reelSnap = await getDoc(reelRef);

            if (reelSnap.exists()) {
                const data = reelSnap.data();
                
                let username = "User";
                let userAvatar = "https://via.placeholder.com/50";
                
                if (data.userId) {
                    const userDoc = await getDoc(doc(db, "users", data.userId));
                    if (userDoc.exists()) {
                        const uData = userDoc.data();
                        username = uData.displayName || uData.username || "User";
                        userAvatar = uData.photoURL || uData.avatar || "https://via.placeholder.com/50";
                    }
                }

                const isLiked = data.likesArr && data.likesArr.includes(currentUser.uid);
                const isOwner = currentUser.uid === data.userId;

                // FIX 1: Add loop=1 and playlist={VIDEO_ID} to enable looping of a single video
                const ytUrl = `https://www.youtube.com/embed/${data.youtubeId}?autoplay=${prepend ? 1 : 0}&loop=1&playlist=${data.youtubeId}&controls=0&modestbranding=1&rel=0&playsinline=1&enablejsapi=1&showinfo=0&iv_load_policy=3&fs=0&disablekb=1`;

                // FIX 2: Create a unique DOM ID so duplicates (in infinite loop) function independently
                const uniqueSuffix = Math.random().toString(36).substr(2, 9);
                const domId = `${reelId}-${uniqueSuffix}`;

                const html = `
                <div class="reel-page" id="reel-${domId}" data-id="${reelId}">
                    
                    <div class="video-wrapper">
                        <iframe id="iframe-${domId}" 
                                src="${ytUrl}" 
                                allow="autoplay; encrypted-media" 
                                title="${data.title}"></iframe>
                    </div>
                    
                    <div class="click-layer" onclick="handleTap(event, '${reelId}', '${domId}')"></div>
                    
                    <i class="fas fa-heart big-heart" id="big-heart-${domId}"></i>

                    <div class="top-options" onclick="toggleMenu('${domId}')">
                        <i class="fas fa-ellipsis-h" style="font-size:20px;"></i>
                    </div>
                    
                    <div class="options-menu" id="menu-${domId}">
                         <div class="menu-item" onclick="alert('Report feature coming soon')">
                            <i class="fas fa-flag"></i> Report
                        </div>
                        ${isOwner ? `
                        <div class="menu-item danger" onclick="deleteReel('${reelId}', '${domId}')">
                            <i class="fas fa-trash"></i> Delete
                        </div>
                        ` : ''}
                    </div>

                    <div class="actions-bar">
                        <div class="avatar-container" onclick="window.location.href='me.html?uid=${data.userId}'">
                            <img src="${userAvatar}" class="avatar-img">
                            ${!isOwner ? `<div class="follow-plus" id="follow-btn-${data.userId}-${uniqueSuffix}" onclick="toggleFollow('${data.userId}', this); event.stopPropagation();"><i class="fas fa-plus"></i></div>` : ''}
                        </div>

                        <div class="action-btn" id="like-btn-${domId}" onclick="toggleLike('${reelId}', '${domId}')">
                            <i class="${isLiked ? 'fas liked' : 'far'} fa-heart"></i>
                            <span>${data.likes || 0}</span>
                        </div>

                        <div class="action-btn" onclick="openComments('${reelId}', '${domId}')">
                            <i class="fas fa-comment-dots"></i>
                            <span id="comment-count-display-${domId}">${data.commentsCount || 0}</span>
                        </div>

                        <div class="action-btn" onclick="toggleSave('${reelId}', this)">
                            <i class="fas fa-star"></i>
                            <span>Save</span>
                        </div>

                        <div class="action-btn">
                            <i class="fas fa-share"></i>
                            <span>Share</span>
                        </div>
                    </div>

                    <div class="reel-info">
                        <span class="user-name" onclick="window.location.href='me.html?uid=${data.userId}'">@${username}</span>
                        <div class="reel-desc">${data.content || data.title}</div>
                        <div class="music-note">
                            <i class="fas fa-music"></i> 
                            <div class="scrolling-text">Original Audio - ${username}</div>
                        </div>
                    </div>
                </div>
                `;

                if (prepend) {
                    reelsContainer.innerHTML = html + reelsContainer.innerHTML;
                    currentReelId = reelId;
                } else {
                    // Append normally
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = html;
                    reelsContainer.appendChild(tempDiv.firstElementChild);
                }

                if (!isOwner && data.userId) {
                    checkIfFollowing(data.userId, uniqueSuffix);
                }
            }
        }

        async function checkIfFollowing(targetUid, suffix) {
            const btn = document.getElementById(`follow-btn-${targetUid}-${suffix}`);
            if (!btn) return;
            
            const docRef = doc(db, "users", currentUser.uid, "following", targetUid);
            const docSnap = await getDoc(docRef);
            if (docSnap.exists()) {
                btn.style.display = 'none';
            }
        }

        // FIX 3: Infinite Loop Logic in loadMoreReels
        async function loadMoreReels(excludeId) {
            if (isFetching) return;
            isFetching = true;

            try {
                let q = query(collection(db, "reels"), orderBy("createdAt", "desc"), limit(3));
                
                if (lastVisibleDoc) {
                    q = query(collection(db, "reels"), orderBy("createdAt", "desc"), startAfter(lastVisibleDoc), limit(3));
                }

                const querySnapshot = await getDocs(q);

                if (querySnapshot.empty) {
                    // End of DB reached? Loop back to start!
                    // Reset pagination
                    lastVisibleDoc = null;
                    // Trigger load again immediately (which will fetch from top)
                    isFetching = false;
                    await loadMoreReels(excludeId); 
                    return;
                }

                // Update cursor
                lastVisibleDoc = querySnapshot.docs[querySnapshot.docs.length - 1];

                for (const docSnap of querySnapshot.docs) {
                    if (docSnap.id !== excludeId) {
                        await loadReel(docSnap.id);
                    }
                }
            } catch (error) {
                console.error("Error loading reels:", error);
            } finally {
                isFetching = false;
            }
        }

        // --- Tap Logic ---
        let lastTap = 0;
        let tapTimeout;

        // Updated to accept unique domId
        window.handleTap = (e, reelId, domId) => {
            const currentTime = new Date().getTime();
            const tapLength = currentTime - lastTap;
            
            clearTimeout(tapTimeout);

            if (tapLength < 300 && tapLength > 0) {
                // Double Tap -> Like
                triggerDoubleTapLike(reelId, domId);
                lastTap = 0;
            } else {
                // Single Tap -> Play/Pause
                tapTimeout = setTimeout(() => {
                    togglePlay(domId);
                    lastTap = 0;
                }, 300);
                lastTap = currentTime;
            }
        };

        function triggerDoubleTapLike(reelId, domId) {
            const heart = document.getElementById(`big-heart-${domId}`);
            heart.classList.remove('animate');
            void heart.offsetWidth; 
            heart.classList.add('animate');

            const btn = document.getElementById(`like-btn-${domId}`);
            const icon = btn.querySelector('i');
            if (!icon.classList.contains('liked')) {
                toggleLike(reelId, domId);
            }
        }

        function togglePlay(domId) {
            const iframe = document.getElementById(`iframe-${domId}`);
            if (!iframe) return;
            const isPaused = iframe.getAttribute('data-paused') === 'true';
            
            if (isPaused) {
                iframe.contentWindow.postMessage('{"event":"command","func":"playVideo","args":""}', '*');
                iframe.setAttribute('data-paused', 'false');
            } else {
                iframe.contentWindow.postMessage('{"event":"command","func":"pauseVideo","args":""}', '*');
                iframe.setAttribute('data-paused', 'true');
            }
        }

        // --- Like Logic (Updated for DOM ID) ---
        window.toggleLike = async (reelId, domId) => {
            const btn = document.getElementById(`like-btn-${domId}`);
            const icon = btn.querySelector('i');
            const span = btn.querySelector('span');
            const ref = doc(db, "reels", reelId); // Use real ID for DB
            
            if (icon.classList.contains('fas') && icon.classList.contains('liked')) {
                // Unlike
                icon.classList.replace('fas', 'far');
                icon.classList.remove('liked');
                span.innerText = Math.max(0, parseInt(span.innerText) - 1);
                await updateDoc(ref, {
                    likes: parseInt(span.innerText),
                    likesArr: arrayRemove(currentUser.uid)
                });
            } else {
                // Like
                icon.classList.replace('far', 'fas');
                icon.classList.add('liked');
                span.innerText = parseInt(span.innerText) + 1;
                await updateDoc(ref, {
                    likes: parseInt(span.innerText),
                    likesArr: arrayUnion(currentUser.uid)
                });
            }
        };

        // --- Follow Logic ---
        window.toggleFollow = async (targetUid, btn) => {
            btn.style.display = 'none';

            const batch = writeBatch(db);
            const currentUserRef = doc(db, "users", currentUser.uid);
            const targetUserRef = doc(db, "users", targetUid);
            const followingRef = doc(db, "users", currentUser.uid, "following", targetUid);
            const followerRef = doc(db, "users", targetUid, "followers", currentUser.uid);

            try {
                batch.set(followingRef, { timestamp: serverTimestamp() });
                batch.set(followerRef, { timestamp: serverTimestamp() });
                batch.set(currentUserRef, { followingCount: increment(1) }, { merge: true });
                batch.set(targetUserRef, { followersCount: increment(1) }, { merge: true });

                await batch.commit();
            } catch (e) {
                console.error("Follow error:", e);
                btn.style.display = 'flex';
                alert("Failed to follow.");
            }
        };

        window.toggleMenu = (domId) => {
            document.querySelectorAll('.options-menu').forEach(m => {
                if(m.id !== `menu-${domId}`) m.classList.remove('show');
            });
            const menu = document.getElementById(`menu-${domId}`);
            menu.classList.toggle('show');
            
            setTimeout(() => {
                const closeMenu = (e) => {
                    if(!menu.contains(e.target) && !e.target.closest('.top-options')) {
                        menu.classList.remove('show');
                        document.removeEventListener('click', closeMenu);
                    }
                };
                document.addEventListener('click', closeMenu);
            }, 100);
        };

        window.deleteReel = async (reelId, domId) => {
            if(confirm("Are you sure you want to delete this reel?")) {
                await deleteDoc(doc(db, "reels", reelId));
                const el = document.getElementById(`reel-${domId}`);
                if(el) el.remove();
                alert("Reel deleted.");
            }
        };
        
        window.toggleSave = (id, btn) => {
            const icon = btn.querySelector('i');
            if(icon.classList.contains('fas')) {
                icon.classList.replace('fas', 'far');
                icon.style.color = 'white';
            } else {
                icon.classList.replace('far', 'fas');
                icon.style.color = '#facc15';
            }
        };

        // --- Comments Logic ---
        const commentsOverlay = document.getElementById('commentsOverlay');
        const commentsSheet = document.getElementById('commentsSheet');
        let commentsUnsubscribe = null;
        let currentDomIdForComments = null;

        window.openComments = (reelId, domId) => {
            currentReelId = reelId;
            currentDomIdForComments = domId;
            commentsOverlay.style.display = 'block';
            setTimeout(() => commentsSheet.style.transform = 'translateY(0)', 10);
            loadComments(reelId, domId);
        };

        window.closeComments = () => {
            commentsSheet.style.transform = 'translateY(100%)';
            setTimeout(() => commentsOverlay.style.display = 'none', 300);
            if(commentsUnsubscribe) commentsUnsubscribe();
        };

        function loadComments(reelId, domId) {
            const list = document.getElementById('commentsList');
            list.innerHTML = '<div style="text-align:center; color:#666; margin-top:20px;">Loading...</div>';

            const q = query(collection(db, "reels", reelId, "comments"), orderBy("createdAt", "desc"));
            
            commentsUnsubscribe = onSnapshot(q, (snapshot) => {
                list.innerHTML = '';
                const count = snapshot.size;
                document.getElementById('commentCountHeader').innerText = `${count} Comments`;
                
                // Update Main Screen Icon Count
                const iconCountDisplay = document.getElementById(`comment-count-display-${domId}`);
                if(iconCountDisplay) iconCountDisplay.innerText = count;

                if (snapshot.empty) {
                    list.innerHTML = '<div style="text-align:center; color:#666; margin-top:20px;">No comments yet.</div>';
                    return;
                }

                snapshot.forEach(doc => {
                    const c = doc.data();
                    const div = document.createElement('div');
                    div.className = 'comment-item';
                    div.innerHTML = `
                        <img src="${c.userAvatar}" class="comment-avatar">
                        <div class="comment-body">
                            <div class="comment-user">@${c.username}</div>
                            <div class="comment-text">${c.text}</div>
                            <div class="comment-meta">
                                <span>${c.createdAt ? new Date(c.createdAt.toDate()).toLocaleDateString() : 'Just now'}</span>
                                <span class="reply-link" onclick="replyTo('${c.username}')">Reply</span>
                            </div>
                        </div>
                        <div style="font-size:12px; color:#666;">
                            <i class="far fa-heart"></i>
                        </div>
                    `;
                    list.appendChild(div);
                });
            });
        }

        // Reply Logic
        window.replyTo = (name) => {
            const input = document.getElementById('commentInput');
            input.value = `@${name} `;
            input.focus();
        };

        window.postComment = async () => {
            const input = document.getElementById('commentInput');
            const text = input.value.trim();
            if (!text) return;

            const batch = writeBatch(db);
            const reelRef = doc(db, "reels", currentReelId);
            const commentRef = doc(collection(db, "reels", currentReelId, "comments"));

            batch.set(commentRef, {
                text: text,
                userId: currentUser.uid,
                username: currentUser.displayName || "User",
                userAvatar: currentUser.photoURL || "https://via.placeholder.com/32",
                createdAt: serverTimestamp(),
                likes: 0
            });

            // Update comment count on reel document
            batch.update(reelRef, { commentsCount: increment(1) });

            await batch.commit();
            input.value = '';
        };

        // --- Scroll Snap / Autoplay / Infinite Scroll Trigger ---
        const observerOptions = { root: null, threshold: 0.6 };
        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                // Find iframe within the intersecting div (don't rely on IDs for this due to duplicates)
                const iframe = entry.target.querySelector('iframe');
                if (!iframe) return;

                if (entry.isIntersecting) {
                    iframe.contentWindow.postMessage('{"event":"command","func":"playVideo","args":""}', '*');
                    iframe.setAttribute('data-paused', 'false');

                    // FIX 3 (Part B): Detect if we are at the last reel to load more (or loop)
                    const allReels = document.querySelectorAll('.reel-page');
                    const lastReel = allReels[allReels.length - 1];
                    if (entry.target === lastReel) {
                        loadMoreReels();
                    }

                } else {
                    iframe.contentWindow.postMessage('{"event":"command","func":"pauseVideo","args":""}', '*');
                    iframe.setAttribute('data-paused', 'true');
                }
            });
        }, observerOptions);

        const mutationObserver = new MutationObserver((mutations) => {
            mutations.forEach((mutation) => {
                mutation.addedNodes.forEach((node) => {
                    if (node.nodeType === 1 && node.classList.contains('reel-page')) {
                        observer.observe(node);
                    }
                });
            });
        });

        mutationObserver.observe(reelsContainer, { childList: true });

    </script>
</body>
</html>